/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   improved_bvh.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chrleroy <chrleroy@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/22 18:30:05 by chrleroy          #+#    #+#             */
/*   Updated: 2025/08/22 18:45:47 by chrleroy         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minirt.h"

/*
** leaf_node_case - Create a leaf node with objects
*/
static void	leaf_node_case(t_object **objects, t_bvh_node *node, int count)
{
	int	i;

	i = 0;
	node->objects = safe_malloc(sizeof(t_object *) * count);
	while (i < count)
	{
		node->objects[i] = objects[i];
		i++;
	}
	node->object_count = count;
	node->left = NULL;
	node->right = NULL;
}

/*
** internal_node_case - Create an internal node with children using improved SAH
*/
static void	internal_node_case(t_object **objects, t_bvh_node *node, int count)
{
	int	axis;
	int	split;

	axis = 0;
	split = 0;
	
	// Use the improved SAH implementation
	split = find_sah_split(objects, count, &axis, &split);
	
	// Create child nodes
	node->left = build_bvh_recursive(objects, split);
	node->right = build_bvh_recursive(objects + split, count - split);
}

/*
** build_bvh_recursive - Recursively build BVH tree with improved SAH
*/
t_bvh_node	*build_bvh_recursive(t_object **objects, int count)
{
	int			i;
	t_bvh_node	*node;
	t_aabb		bounds;

	if (count <= 0)
		return (NULL);
	node = safe_malloc(sizeof(t_bvh_node));
	if (!node)
		return (NULL);
		
	// Compute bounding box for all objects
	i = 0;
	if (count > 0)
		bounds = get_object_bounds(objects[0]);
	else
		bounds = create_empty_aabb();
		
	i = 1;
	while (i < count)
	{
		bounds = aabb_union(bounds, get_object_bounds(objects[i]));
		i++;
	}
	node->bounds = bounds;
	
	// Decide whether to create a leaf or internal node
	if (count <= MAX_OBJECTS_PER_LEAF)
	{
		leaf_node_case(objects, node, count);
		return (node);
	}
	
	// Create internal node
	node->objects = NULL;
	node->object_count = 0;
	internal_node_case(objects, node, count);
	
	return (node);
}
