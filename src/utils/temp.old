/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sah.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chrleroy <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/10 10:24:05 by chrleroy          #+#    #+#             */
/*   Updated: 2025/08/19 08:45:47 by chrleroy         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
 
#include "../../includes/minirt.h"

static t_vec3	get_object_centroids(t_object *object)
{
	if (object->type <= CYLINDER)
		return (object->position);
	else if (object->type == TRIANGLE)
		return (object->axis);
	return ((t_vec3){0, 0, 0});
}

static t_vec3	*fill_min_and_max_vector(t_object **objects, 
	t_vec3 *min_val, t_vec3 *max_val, int count)
{
	int		i;
	t_vec3	*center;

	i = 0;
	center = safe_malloc(sizeof(t_vec3) * count);
	while (i < count)
	{
		center[i] = get_object_centroids(objects[i]);
		*min_val = vec3_min(*min_val, center[i]);
		*max_val = vec3_max(*max_val, center[i]);
		i++;
	}
	return (center);
}

int find_sah_split(t_object **objects, int count, int *best_axis, int *best_split)
{
	int (axis) = 0;
    double (best_cost) = INFINITY;
    t_vec3 (min_val) = {INFINITY, INFINITY, INFINITY};
    t_vec3 (max_val) = {-INFINITY, -INFINITY, -INFINITY};
    // Analyser rapidement la distribution (O(n)) && garder les cetroids en cache
	t_vec3	*centers = fill_min_and_max_vector(objects, &min_val, &max_val, count);
    // Évaluer chaque axe
	while (axis < 3)
	{
        // Early return pour axe plat
        if (max_val.[axis] - min_val.e[axis] < 1e-6)
            continue;
            
        // Répartir en bins (pas besoin de tri)
        for (int bin = 1; bin < 12; bin++) {
            double split_pos = min_val.e[axis] + (max_val.e[axis] - min_val.e[axis]) * bin / 12.0;

            // Compter et calculer AABBs de chaque côté
            t_aabb left_box = empty_aabb();
            t_aabb right_box = empty_aabb();
            int left_count = 0;
            
            for (int i = 0; i < count; i++) {
                if (centers[i].e[axis] < split_pos) {
                    left_box = aabb_union(left_box, get_object_bounds(objects[i]));
                    left_count++;
                } else {
                    right_box = aabb_union(right_box, get_object_bounds(objects[i]));
                }
            }
            
            int right_count = count - left_count;
            if (left_count == 0 || right_count == 0)
                continue;
                
            // Calculer coût normalisé
            double parent_area = aabb_surface(aabb_union(left_box, right_box));
            double cost = (aabb_surface(left_box) * left_count + 
                          aabb_surface(right_box) * right_count) / parent_area;
                          
            if (cost < best_cost) {
                best_cost = cost;
                *best_axis = axis;
                *best_split = left_count;  // Retenir le nombre d'objets, pas la position
            }
            
            // Early return si coût suffisamment bon
            if (best_cost < 0.7)  // 30% meilleur que le parent
                return left_count;
        }
    }
    
    // Partitionner les objets en fonction du meilleur axe/position
    if (*best_axis < 3) {
        // Partitionner sans tri complet (quickselect)
        partition_objects_by_axis(objects, count, *best_axis, *best_split);
    }
    
    return *best_split;
}